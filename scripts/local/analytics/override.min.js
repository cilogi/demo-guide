var Cilogi = Cilogi || {};

!function(Cilogi) {
    "use strict";
    function keys(obj) {
        if (obj !== Object(obj)) return [];
        if (Object.keys) return Object.keys(obj);
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys;
    }
    function each(obj, iterator, context) {
        var nativeForEach = Array.prototype.forEach;
        if (null == obj) return obj;
        if (nativeForEach && obj.forEach === nativeForEach) obj.forEach(iterator, context); else if (obj.length === +obj.length) {
            for (var i = 0, length = obj.length; length > i; i++) if (iterator.call(context, obj[i], i, obj) === breaker) return;
        } else for (var keys = keys(obj), i = 0, length = keys.length; length > i; i++) if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        return obj;
    }
    function extend(obj) {
        var key, array = Array.prototype.slice.call(arguments, 1);
        return each(array, function(arg) {
            if (arg) for (key in arg) obj[key] = arg[key];
        }), obj;
    }
    function parseURL(url) {
        var searchBase, queries, split, i, parser = document.createElement("a"), searchParameters = {};
        for (parser.href = url, searchBase = parser.search.replace(/^\?/, ""), queries = searchBase.split("&"), 
        i = 0; i < queries.length; i++) split = queries[i].split("="), searchParameters[split[0]] = split[1];
        return {
            protocol: parser.protocol,
            host: parser.host,
            hostname: parser.hostname,
            port: parser.port,
            pathname: parser.pathname,
            search: searchBase,
            searchParameters: searchParameters,
            hash: parser.hash
        };
    }
    function log() {
        "undefined" != typeof console && console.log(Array.prototype.slice.call(arguments, 0));
    }
    var breaker = {};
    Cilogi.keys = keys, Cilogi.each = each, Cilogi.extend = extend, Cilogi.parseURL = parseURL, 
    Cilogi.log = log;
}(Cilogi), function(Cilogi) {
    "use strict";
    function parseQuery(query) {
        for (var map = {}, vars = query.split("&"), i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            map[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return map;
    }
    function uuid() {
        var d = new Date().getTime(), uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            var r = (d + 16 * Math.random()) % 16 | 0;
            return d = Math.floor(d / 16), ("x" == c ? r : 7 & r | 8).toString(16);
        });
        return uuid;
    }
    function Hit(query) {
        var map;
        this.query = query, map = parseQuery(query), this.clientId = map.clientId ? map.clientId : uuid, 
        this.uuid = uuid, this.status = STATUS_BATCH, this.sent = Hit.UNSENT;
    }
    var IS_SENT = "sent", IS_UNSENT = "unsent", STATUS_BATCH = "batch", uuid = uuid();
    Hit.SENT = IS_SENT, Hit.UNSENT = IS_UNSENT, Hit.prototype.setStatus = function(status) {
        return this.status = status, this;
    }, Hit.prototype.setSent = function(sentValue) {
        return this.sent = sentValue, this;
    }, Hit.prototype.toJSON = function() {
        var obj = {
            clientId: this.clientId,
            uuid: this.uuid,
            query: this.query,
            created: new Date(),
            status: this.status,
            sent: this.sent
        };
        return obj;
    }, Cilogi.Hit = Hit;
}(Cilogi), function(Cilogi, Hit, log) {
    "use strict";
    function setReplacements() {
        if (window.shimIndexedDB) {
            var replace = window.shimIndexedDB.__replacements();
            indexedDB = replace.indexedDB, IDBTransaction = replace.IDBTransaction, IDBKeyRange = replace.IDBKeyRange, 
            IDBDatabase = replace.IDBDatabase, IDBCursor = replace.IDBCursor;
        }
    }
    function initDB() {
        var request = indexedDB.open(DB_NAME, 1);
        request.onsuccess = function() {
            db = request.result, dbLoading = !1;
        }, request.onerror = function() {
            log("IndexedDB error: " + request.errorCode), dbLoading = !1;
        }, request.onupgradeneeded = function() {
            var objectStore = request.result.createObjectStore("hits", {
                autoIncrement: !0
            });
            objectStore.createIndex(INDEX_FIELD, INDEX_FIELD, {
                unique: !1
            });
        };
    }
    function addHit(hitData, onSuccess, onError) {
        var hit = new Hit(hitData), json = hit.toJSON();
        if (db) {
            var transaction = db.transaction(DB_STORE, "readwrite"), store = transaction.objectStore(DB_STORE), text = JSON.stringify(json);
            log("  addHit, adding " + text);
            var request = store.add(json);
            return request.onsuccess = function() {
                log("  addHit succeeded for " + text), onSuccess && onSuccess(request);
            }, request.onerror = function() {
                log("  addHit failed: " + request.error.name + " for data " + text), onError && onError(request);
            }, !0;
        }
        return dbLoading ? void window.setTimeout(function() {
            log("50ms timeout waiting for database to initialize"), addHit(hitData, onSuccess, onError);
        }, 50) : !1;
    }
    function markDone(keyIndices, callback) {
        if (db) {
            var count, transaction = db.transaction(DB_STORE, "readwrite"), store = transaction.objectStore(DB_STORE);
            count = keyIndices.length, markKeyDone(store, count, keyIndices, callback);
        }
    }
    function markKeyDone(store, count, keys, callback) {
        if (0 >= count) callback(); else {
            var response, key = keys[count - 1], request = store.get(key);
            request.onsuccess = function() {
                var value = request.result;
                value ? (value[INDEX_FIELD] = Hit.SENT, response = store.put(value, key), response.onsuccess = function() {
                    markKeyDone(store, count - 1, keys, callback);
                }) : (log("Warning: There is no value for " + key), markKeyDone(store, count - 1, keys, callback));
            }, request.onerror = function() {
                log("Can't update hit with key: " + key + ", aborting");
            };
        }
    }
    function fillPacket(packet, callback) {
        if (db) {
            var transaction = db.transaction(DB_STORE, "readwrite"), store = transaction.objectStore(DB_STORE), storeIndex = store.index(INDEX_FIELD), range = IDBKeyRange.only(Hit.UNSENT), request = storeIndex.openCursor(range);
            request.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (cursor.value.query) {
                        if (!packet.addHit(cursor.value.query, cursor.primaryKey)) return void callback();
                    } else cursor.delete();
                    cursor.continue();
                } else log("No more entries! Queue is empty: " + packet.getNHits()), callback();
            }, request.onerror = function(e) {
                packet.controller.setSendingPacket(!1), log("Error getting cursor: " + e.message);
            };
        } else window.setTimeout(function() {
            log("50ms timeout waiting for database to initialize"), fillPacket(packet, callback);
        }, 50);
    }
    var DB_NAME = "hitDB", DB_STORE = "hits", INDEX_FIELD = "sent", indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB, IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction, IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange, IDBDatabase = window.IDBDatabase || window.webkitIDBDatabase || window.msIDBDatabase, IDBCursor = window.IDBCursor || window.webkitIDBCursor || window.msIDBCursor, db = null, dbLoading = !0;
    setReplacements(), Cilogi.dbFuns = {
        addHit: addHit,
        markDone: markDone,
        fillPacket: fillPacket,
        index: "sent"
    }, initDB();
}(Cilogi, Cilogi.Hit, Cilogi.log), function(Cilogi, Hit, log) {
    "use strict";
    function Packet(controller, options) {
        this.options = Cilogi.extend({}, {
            maxHits: MAX_HITS,
            host: ""
        }, options), this.controller = controller, this.hits = [], this.keys = [], this.delay = DEFAULT_DELAY_MS, 
        this.nHits = 0, this.singleHitUrl = SINGLE_HIT_URL, this.batchHitUrl = BATCH_HIT_URL, 
        this.timeoutId = 0;
    }
    var DEFAULT_TIMEOUT_MS = 5e3, DEFAULT_DELAY_MS = 100, MAX_DELAY_MS = 25600, MAX_HITS = 10, BATCH_HIT_URL = "/control/batch", SINGLE_HIT_URL = "/control/single";
    Packet.prototype.singleHit = function(data) {
        var hit = new Hit(data).setStatus("single"), url = this.options.host + this.singleHitUrl, msg = JSON.stringify([ hit ]);
        log("single hit with URL " + url), $.ajax(url, {
            type: "POST",
            data: msg,
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            xhrFields: {
                withCredentials: !0
            },
            timeout: DEFAULT_TIMEOUT_MS
        }).fail(function(_, status, error) {
            log("Single HIT FAIL, status: " + status + ", error: " + error);
        });
    }, Packet.prototype.toJSON = function() {
        return {
            hits: this.hits
        };
    }, Packet.prototype.addHit = function(hitData, key) {
        return log("AddHit, data is " + hitData), hitData && !this.isFull() ? (this.hits.push(new Hit(hitData)), 
        this.nHits++, this.keys.push(key), !0) : !1;
    }, Packet.prototype.isFull = function() {
        return this.nHits >= this.options.maxHits;
    }, Packet.prototype.getKeys = function() {
        return this.keys;
    }, Packet.prototype.getNHits = function() {
        return this.nHits;
    }, Packet.prototype.getDelay = function() {
        return this.delay;
    }, Packet.prototype.adjustDelayOnFailure = function() {
        this.delay < MAX_DELAY_MS && (this.delay *= 2);
    }, Packet.prototype.setStatus = function(hits, status) {
        return Cilogi.each(hits, function(hit) {
            hit.setStatus(status);
        }), hits;
    }, Packet.prototype.send = function() {
        var jsonData;
        this.getNHits() > 0 && (this.timeoutId && (this.timeoutId = 0, window.clearTimeout(this.timeoutId)), 
        jsonData = JSON.stringify(this.setStatus(this.hits, "batch")), $.ajax(this.options.host + this.batchHitUrl, {
            type: "POST",
            data: jsonData,
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            xhrFields: {
                withCredentials: !0
            },
            timeout: DEFAULT_TIMEOUT_MS
        }).done(function() {
            this.controller.markDone(this.getKeys(), function() {
                this.controller.setSendingPacket(!1), this.controller.sendPacket(this.options);
            }.bind(this));
        }.bind(this)).fail(function() {
            this.adjustDelayOnFailure(), this.sendWithDelay();
        }.bind(this)));
    }, Packet.prototype.sendWithDelay = function() {
        Cilogi.log("delaying call by " + this.delay + "ms on failure"), this.timeoutId = window.setTimeout(function() {
            this.send();
        }.bind(this), this.delay);
    }, Cilogi.Packet = Packet;
}(Cilogi, Cilogi.Hit, Cilogi.log), function(Cilogi, Packet, dbFuns, log) {
    "use strict";
    function Control() {
        this.sendingPacket = !1;
    }
    Control.prototype.addHit = function(data, options) {
        function addHitSuccess() {
            this.sendPacket(options);
        }
        function addHitError() {
            window.setTimeout(function() {
                this.addHit(data, options);
            }.bind(this), 50);
        }
        return log("Control add hit"), data ? void dbFuns.addHit(data, addHitSuccess.bind(this), addHitError.bind(this)) : void log("  Control add hit no data");
    }, Control.prototype.singleHit = function(data, options) {
        var packet = new Packet(this, options);
        packet.singleHit(data);
    }, Control.prototype.sendPacket = function(options) {
        if (!this.sendingPacket) {
            var packet = new Packet(this, options);
            this.setSendingPacket(!0);
            try {
                dbFuns.fillPacket(packet, function() {
                    packet.getNHits() ? (log("sending packet with keys: " + JSON.stringify(packet.getKeys())), 
                    packet.send()) : this.setSendingPacket(!1);
                }.bind(this));
            } catch (e) {
                log("Error filling packet: " + e.message), this.setSendingPacket(!1);
            }
        }
    }, Control.prototype.setSendingPacket = function(bool) {
        this.sendingPacket = bool;
    }, Control.prototype.markDone = function(keys, callback) {
        dbFuns.markDone(keys, callback);
    }, Cilogi.Control = Control;
}(Cilogi, Cilogi.Packet, Cilogi.dbFuns, Cilogi.log), function(log, PacketControl) {
    "use strict";
    function sendBeacon(url) {
        log("sending beacon to: " + url + " NOT IMPLEMENTED");
    }
    function hitFunction(options) {
        return log("HIT called"), function(url) {
            var parse = Cilogi.parseURL(url);
            packetControl.singleHit(parse.search, options), packetControl.addHit(parse.search, options);
        };
    }
    function install(options) {
        var image = function(width, height) {
            return 1 != width || 1 != height ? oldImage : (Object.defineProperty(this, "src", {
                set: hitFunction(options)
            }), void log("created image, width: " + width + " height: " + height));
        };
        window.Image = image, navigator.sendBeacon = sendBeacon, document.createElement = function(name) {
            return "img" == name.toLowerCase() ? new image(1, 1) : oldCreateElement.call(this, name);
        };
    }
    function uninstall() {
        window.Image = oldImage, navigator.sendBeacon = oldSendBeacon, document.createElement = oldCreateElement;
    }
    function replace(options) {
        var args, oldGa = window.ga, opt = Cilogi.extend({
            host: ""
        }, options);
        window.ga = function() {
            install(opt), args = Array.prototype.slice.call(arguments, 0), "send" == args[0] && args.push({
                hitCallback: uninstall
            }), oldGa.apply(window, args);
        };
    }
    function replaceTracker(tracker, options) {
        var args, oldSend = tracker.send, opt = Cilogi.extend({
            host: ""
        }, options);
        tracker.send = function() {
            install(opt), args = Array.prototype.slice.call(arguments, 0), oldSend.apply(tracker, args), 
            uninstall();
        };
    }
    var oldImage = window.Image, oldSendBeacon = navigator.sendBeacon, oldCreateElement = document.createElement, packetControl = new PacketControl();
    window.installGaOverride = replace, window.installTrackerOverride = replaceTracker;
}(Cilogi.log, Cilogi.Control);