var Cilogi = Cilogi || {};

!function(Cilogi) {
    function keys(obj) {
        if (obj !== Object(obj)) return [];
        if (Object.keys) return Object.keys(obj);
        var keys = [];
        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
        return keys;
    }
    function each(obj, iterator, context) {
        var nativeForEach = Array.prototype.forEach;
        if (null == obj) return obj;
        if (nativeForEach && obj.forEach === nativeForEach) obj.forEach(iterator, context); else if (obj.length === +obj.length) {
            for (var i = 0, length = obj.length; length > i; i++) if (iterator.call(context, obj[i], i, obj) === breaker) return;
        } else for (var keys = keys(obj), i = 0, length = keys.length; length > i; i++) if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
        return obj;
    }
    function extend(obj) {
        var key, array = Array.prototype.slice.call(arguments, 1);
        return each(array, function(arg) {
            if (arg) for (key in arg) obj[key] = arg[key];
        }), obj;
    }
    function parseURL(url) {
        var searchBase, queries, split, i, parser = document.createElement("a"), searchParameters = {};
        for (parser.href = url, searchBase = parser.search.replace(/^\?/, ""), queries = searchBase.split("&"), 
        i = 0; i < queries.length; i++) split = queries[i].split("="), searchParameters[split[0]] = split[1];
        return {
            protocol: parser.protocol,
            host: parser.host,
            hostname: parser.hostname,
            port: parser.port,
            pathname: parser.pathname,
            search: searchBase,
            searchParameters: searchParameters,
            hash: parser.hash
        };
    }
    function log() {
        "undefined" != typeof console && console.log(Array.prototype.slice.call(arguments, 0));
    }
    var breaker = {};
    Cilogi.keys = keys, Cilogi.each = each, Cilogi.extend = extend, Cilogi.parseURL = parseURL, 
    Cilogi.log = log;
}(Cilogi), function(Cilogi) {
    function parseQuery(query) {
        for (var map = {}, vars = query.split("&"), i = 0; i < vars.length; i++) {
            var pair = vars[i].split("=");
            map[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return map;
    }
    function uuid() {
        var d = new Date().getTime(), uuid = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
            var r = (d + 16 * Math.random()) % 16 | 0;
            return d = Math.floor(d / 16), ("x" == c ? r : 7 & r | 8).toString(16);
        });
        return uuid;
    }
    function Hit(query, key) {
        var map;
        this.query = query, map = parseQuery(query), this.clientId = map.clientId ? map.clientId : uuid, 
        this.uuid = uuid, this.status = STATUS_BATCH, this.sent = Hit.UNSENT, this.setKey(key);
    }
    var IS_SENT = "sent", IS_UNSENT = "unsent", STATUS_BATCH = "batch", uuid = uuid();
    Hit.SENT = IS_SENT, Hit.UNSENT = IS_UNSENT, Hit.prototype.setStatus = function(status) {
        return this.status = status, this;
    }, Hit.prototype.setSent = function(sentValue) {
        return this.sent = sentValue, this;
    }, Hit.prototype.setKey = function(key) {
        return key && (this.key = key), this;
    }, Hit.prototype.toJSON = function() {
        var obj = {
            clientId: this.clientId,
            uuid: this.uuid,
            query: this.query,
            created: new Date(),
            status: this.status,
            sent: this.sent
        };
        return this.key && (obj.key = this.key), obj;
    }, Cilogi.Hit = Hit;
}(Cilogi), function(Cilogi, Hit) {
    function initDB() {
        var request = indexedDB.open(DB_NAME, 1);
        request.onsuccess = function() {
            db = request.result;
        }, request.onerror = function(evt) {
            Cilogi.log("IndexedDB error: " + evt.target.errorCode);
        }, request.onupgradeneeded = function(evt) {
            var objectStore = evt.currentTarget.result.createObjectStore("hits", {
                keyPath: "key",
                autoIncrement: !0
            });
            objectStore.createIndex(index, index, {
                unique: !1
            });
        };
    }
    function addHit(hitData) {
        var hit = new Hit(hitData), json = hit.toJSON();
        if (db) {
            var transaction = db.transaction(DB_STORE, "readwrite"), store = transaction.objectStore(DB_STORE);
            return store.add(json), !0;
        }
        return !1;
    }
    function markDone(keyIndices, callback) {
        if (db) {
            var i, count, key, value, response, transaction = db.transaction(DB_STORE, "readwrite"), store = transaction.objectStore(DB_STORE);
            for (count = 0, i = 0; i < keyIndices.length; i++) key = keyIndices[i], store.get(key).onsuccess = function(e) {
                value = e.target.result, value[index] = Hit.SENT, response = store.put(value), response.onsuccess = function() {
                    count += 1, count >= keyIndices.length && callback();
                };
            };
        }
    }
    function fillPacket(packet, callback) {
        if (db) {
            var transaction = db.transaction(DB_STORE, "readwrite"), store = transaction.objectStore(DB_STORE), storeIndex = store.index(index), range = IDBKeyRange.only(Hit.UNSENT), request = storeIndex.openCursor(range);
            request.onsuccess = function(e) {
                var cursor = e.target.result;
                if (cursor) {
                    if (!packet.addHit(cursor.value.query, cursor.value.key)) return void callback();
                    cursor.continue();
                } else Cilogi.log("No more entries! Packet has been filled (as far as possible): " + packet.getNHits()), 
                callback();
            };
        } else window.setTimeout(function() {
            Cilogi.log("50ms timeout waiting for database to initialize"), fillPacket(packet, callback);
        }, 50);
    }
    var DB_NAME = "hitDB", DB_STORE = "hits", indexedDB = window.indexedDB, index = (window.IDBTransaction, 
    "sent"), db = null;
    initDB(), Cilogi.db = {
        addHit: addHit,
        markDone: markDone,
        fillPacket: fillPacket,
        index: "sent"
    };
}(Cilogi, Cilogi.Hit), function(Cilogi, Hit) {
    "use strict";
    function Packet(controller, options) {
        this.options = Cilogi.extend({}, {
            maxHits: MAX_HITS,
            host: ""
        }, options), this.controller = controller, this.hits = [], this.keys = [], this.delay = DEFAULT_DELAY_MS, 
        this.nHits = 0, this.singleHitUrl = SINGLE_HIT_URL, this.batchHitUrl = BATCH_HIT_URL, 
        this.timeoutId = 0;
    }
    var DEFAULT_TIMEOUT_MS = 5e3, DEFAULT_DELAY_MS = 100, MAX_DELAY_MS = 800, MAX_HITS = 10, BATCH_HIT_URL = "/control/batch", SINGLE_HIT_URL = "/control/single";
    Packet.prototype.singleHit = function(data) {
        var hit = new Hit(data).setStatus("single"), url = this.options.host + this.singleHitUrl, msg = JSON.stringify([ hit ]);
        $.ajax(url, {
            type: "POST",
            data: msg,
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            xhrFields: {
                withCredentials: !0
            },
            timeout: DEFAULT_TIMEOUT_MS
        }).fail(function(_, status, error) {
            Cilogi.log("Single HIT FAIL, status: " + status + ", error: " + error);
        });
    }, Packet.prototype.toJSON = function() {
        return {
            hits: this.hits
        };
    }, Packet.prototype.addHit = function(hitData, key) {
        return hitData && !this.isFull() ? (this.hits.push(new Hit(hitData).setKey(key)), 
        this.nHits++, this.keys.push(key), !0) : !1;
    }, Packet.prototype.isFull = function() {
        return this.nHits >= this.options.maxHits;
    }, Packet.prototype.getKeys = function() {
        return this.keys;
    }, Packet.prototype.getNHits = function() {
        return this.nHits;
    }, Packet.prototype.getDelay = function() {
        return this.delay;
    }, Packet.prototype.adjustDelayOnFailure = function() {
        this.delay < MAX_DELAY_MS && (this.delay *= 2);
    }, Packet.prototype.setStatus = function(hits, status) {
        return Cilogi.each(hits, function(hit) {
            hit.setStatus(status);
        }), hits;
    }, Packet.prototype.send = function() {
        var jsonData;
        this.getNHits() > 0 && (this.timeoutId && (this.timeoutId = 0, window.clearTimeout(this.timeoutId)), 
        jsonData = JSON.stringify(this.setStatus(this.hits, "batch")), $.ajax(this.options.host + this.batchHitUrl, {
            type: "POST",
            data: jsonData,
            contentType: "application/json; charset=utf-8",
            dataType: "json",
            xhrFields: {
                withCredentials: !0
            },
            timeout: DEFAULT_TIMEOUT_MS
        }).done(function() {
            this.controller.markDone(this.getKeys(), function() {
                this.controller.setSendingPacket(!1), this.controller.sendPacket(this.options);
            }.bind(this));
        }.bind(this)).fail(function() {
            this.adjustDelayOnFailure(), this.sendWithDelay();
        }.bind(this)));
    }, Packet.prototype.sendWithDelay = function() {
        Cilogi.log("delaying call by " + this.delay + "ms on failure"), this.timeoutId = window.setTimeout(function() {
            this.send();
        }.bind(this), this.delay);
    }, Cilogi.Packet = Packet;
}(Cilogi, Cilogi.Hit), function(Cilogi, Packet, db) {
    function Control() {
        this.sendingPacket = !1;
    }
    Control.prototype.addHit = function(data, options) {
        db.addHit(data) ? this.sendPacket(options) : window.setTimeout(function() {
            this.addHit(data, options);
        }.bind(this), 50);
    }, Control.prototype.singleHit = function(data, options) {
        var packet = new Packet(this, options);
        packet.singleHit(data);
    }, Control.prototype.sendPacket = function(options) {
        if (!this.sendingPacket) {
            var packet = new Packet(this, options);
            this.setSendingPacket(!0);
            try {
                db.fillPacket(packet, function() {
                    packet.getNHits() && (Cilogi.log("sending packet with keys: " + JSON.stringify(packet.getKeys())), 
                    packet.send());
                }.bind(this));
            } catch (e) {
                Cilogi.log("Error filling packet: " + e.message), this.setSendingPacket(!1);
            }
        }
    }, Control.prototype.setSendingPacket = function(bool) {
        this.sendingPacket = bool;
    }, Control.prototype.markDone = function(keys, callback) {
        db.markDone(keys, callback);
    }, Cilogi.Control = Control;
}(Cilogi, Cilogi.Packet, Cilogi.db), function(log, PacketControl) {
    function sendBeacon(url) {
        log("sending beacon to: " + url + " NOT IMPLEMENTED");
    }
    function hitFunction(options) {
        return function(url) {
            var parse = Cilogi.parseURL(url);
            packetControl.singleHit(parse.search, options), packetControl.addHit(parse.search, options);
        };
    }
    function install(options) {
        var image = function(width, height) {
            Object.defineProperty(this, "src", {
                set: hitFunction(options)
            }), log("created image, width: " + width + " height: " + height);
        };
        window.Image = image, navigator.sendBeacon = sendBeacon, document.createElement = function(name) {
            return "img" == name.toLowerCase() ? new image(1, 1) : oldCreateElement.call(this, name);
        };
    }
    function uninstall() {
        window.Image = oldImage, navigator.sendBeacon = oldSendBeacon, document.createElement = oldCreateElement;
    }
    function replace(options) {
        var args, oldGa = window.ga, opt = Cilogi.extend({
            host: ""
        }, options);
        window.ga = function() {
            install(opt), args = Array.prototype.slice.call(arguments, 0), "send" == args[0] && args.push({
                hitCallback: uninstall
            }), oldGa.apply(window, args);
        };
    }
    var oldImage = window.Image, oldSendBeacon = navigator.sendBeacon, oldCreateElement = document.createElement, packetControl = new PacketControl();
    window.installGaOverride = replace;
}(Cilogi.log, Cilogi.Control);